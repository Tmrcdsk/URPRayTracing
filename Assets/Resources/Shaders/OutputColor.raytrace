#pragma max_recursion_depth 1

#define CBUFFER_START(name) cbuffer name {
#define CBUFFER_END };

CBUFFER_START(CameraBuffer)
  float4x4 _InvCameraViewProj;
  float3   _WorldSpaceCameraPos;
  float    _CameraFarDistance;
CBUFFER_END

struct RayIntersection
{
  float4 color;
};

RaytracingAccelerationStructure _AccelerationStructure;

RWTexture2D<float4> _OutputTarget;

inline void GenerateCameraRay(out float3 origin, out float3 direction)
{
  // center in the middle of the pixel.
  float2 xy = DispatchRaysIndex().xy + 0.5f;
  float2 screenPos = xy / DispatchRaysDimensions().xy * 2.0f - 1.0f;

  // Un project the pixel coordinate into a ray.
  float4 world = mul(_InvCameraViewProj, float4(screenPos, 0, 1));

  world.xyz /= world.w;
  origin = _WorldSpaceCameraPos.xyz;
  direction = normalize(world.xyz - origin);
}

inline float3 BackgroundColor(float3 origin, float3 direction)
{
  float t = 0.5f * (direction.y + 1.0f);
  return (1.0f - t) * float3(1.0f, 1.0f, 1.0f) + t * float3(0.5f, 0.7f, 1.0f);
}

[shader("raygeneration")]
void AddASphereRayGenShader()
{
    const uint2 dispatchIdx = DispatchRaysIndex().xy;
    
    float3 origin;
    float3 direction;
    GenerateCameraRay(origin, direction);

    RayDesc rayDesc;
    rayDesc.Origin = origin;
    rayDesc.Direction = direction;
    rayDesc.TMin = 1e-5f;
    rayDesc.TMax = _CameraFarDistance;

    RayIntersection rayIntersection;
    rayIntersection.color = float4(0.0f, 0.0f, 0.0f, 0.0f);

    TraceRay(_AccelerationStructure, RAY_FLAG_CULL_BACK_FACING_TRIANGLES, 0xFF, 0, 1, 0, rayDesc, rayIntersection);

    _OutputTarget[dispatchIdx] = rayIntersection.color;
}

[shader("miss")]
void MissShader(inout RayIntersection rayIntersection : SV_RayPayload)
{
    float3 origin = WorldRayOrigin();
    float3 direction = WorldRayDirection();
    rayIntersection.color = float4(BackgroundColor(origin, direction), 1.0f);
}
